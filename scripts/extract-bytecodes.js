#!/usr/bin/env node
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const contractsDir = path.join(__dirname, '..', 'contracts');
const verifiersDir = path.join(contractsDir, 'verifiers');
const nodeModules = path.join(__dirname, '..', 'node_modules');
const outputDir = path.join(__dirname, '..', 'build');

// Create output directory
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Contracts to compile
const contracts = [
  { name: 'MerkleAirdropVerifier', path: path.join(verifiersDir, 'MerkleAirdropVerifier.sol') },
  { name: 'SealedBidVerifier', path: path.join(verifiersDir, 'sealed_bidVerifier.sol'), contractName: 'Groth16Verifier' },
  { name: 'MastermindVerifier', path: path.join(verifiersDir, 'mastermindVerifier.sol'), contractName: 'Groth16Verifier' },
  { name: 'MixerVerifier', path: path.join(verifiersDir, 'mixer_demoVerifier.sol'), contractName: 'Groth16Verifier' },
  { name: 'MembershipVerifier', path: path.join(verifiersDir, 'private_membershipVerifier.sol'), contractName: 'Groth16Verifier' },
  { name: 'PrivateAirdrop', path: path.join(contractsDir, 'PrivateAirdrop.sol') },
  { name: 'SealedBidAuction', path: path.join(contractsDir, 'SealedBidAuction.sol') },
  { name: 'MastermindGame', path: path.join(contractsDir, 'MastermindGame.sol') },
  { name: 'SimpleMixer', path: path.join(contractsDir, 'SimpleMixer.sol') },
  { name: 'PrivateClub', path: path.join(contractsDir, 'PrivateClub.sol') },
];

function compileContract(contract) {
  console.log(`Compiling ${contract.name}...`);

  const solFile = contract.path;
  const basePath = path.dirname(solFile);

  try {
    // Use solc with includes
    const cmd = `npx solc --optimize --bin --abi --base-path "${contractsDir}" --include-path "${nodeModules}" --include-path "${verifiersDir}" "${solFile}" -o "${outputDir}" --overwrite 2>&1`;
    const result = execSync(cmd, { encoding: 'utf-8', maxBuffer: 10 * 1024 * 1024 });
    console.log(`  Compiled successfully`);
    return true;
  } catch (err) {
    console.error(`  Error compiling ${contract.name}:`, err.message);
    return false;
  }
}

// Compile all contracts
const results = {};
for (const contract of contracts) {
  const success = compileContract(contract);
  if (success) {
    const contractName = contract.contractName || contract.name;
    const binFile = path.join(outputDir, `${path.basename(contract.path, '.sol')}_${contractName}.bin`);
    const abiFile = path.join(outputDir, `${path.basename(contract.path, '.sol')}_${contractName}.abi`);

    // Try different possible output filenames
    const possibleBinFiles = [
      binFile,
      path.join(outputDir, `${contractName}.bin`),
      path.join(outputDir, `${path.basename(contract.path, '.sol')}.bin`),
    ];

    for (const bf of possibleBinFiles) {
      if (fs.existsSync(bf)) {
        results[contract.name] = {
          bytecode: '0x' + fs.readFileSync(bf, 'utf-8').trim(),
          binFile: bf
        };
        console.log(`  Found bytecode at: ${bf}`);
        break;
      }
    }
  }
}

// Output results
console.log('\n=== Bytecodes ===');
for (const [name, data] of Object.entries(results)) {
  console.log(`${name}: ${data.bytecode.slice(0, 30)}...`);
}

// Generate TypeScript file
let tsContent = '// Auto-generated bytecodes\n\n';
for (const [name, data] of Object.entries(results)) {
  const varName = name.toUpperCase().replace(/([A-Z])/g, '_$1').replace(/^_/, '') + '_BYTECODE';
  tsContent += `export const ${varName} = "${data.bytecode}" as \`0x\${string}\`;\n`;
}

fs.writeFileSync(path.join(outputDir, 'bytecodes.ts'), tsContent);
console.log(`\nGenerated bytecodes.ts in ${outputDir}`);
